---
---

<div class="hero-canvas" aria-hidden="true">
	<canvas id="heroCanvas" aria-hidden="true"></canvas>
</div>

<style>
	.hero-canvas {
		display: none;
		position: relative;
		width: min(420px, 100%);
		aspect-ratio: 1;
		border-radius: var(--border-radius);
		overflow: hidden;
		cursor: auto;
		background: transparent;
	}

	#heroCanvas {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 2;
	}

	@media (min-width: 980px) {
		.hero-canvas {
			display: block;
		}
	}

</style>

<script type="module">
	import { gsap } from 'https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js';
	import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';

	if (typeof window === 'undefined') {
		throw new Error('Window not available');
	}

	const canvas = document.getElementById('heroCanvas');
	if (!canvas) {
		throw new Error('Canvas not found');
	}

const renderer = new THREE.WebGLRenderer({
	canvas,
	antialias: true,
	alpha: true,
});
renderer.setSize(canvas.clientWidth, canvas.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

const createMetalTexture = () => {
	const textureCanvas = document.createElement('canvas');
	textureCanvas.width = textureCanvas.height = 256;
	const ctx = textureCanvas.getContext('2d');

	const gradient = ctx.createLinearGradient(0, 0, textureCanvas.width, textureCanvas.height);
	gradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
	gradient.addColorStop(0.45, 'rgba(200, 210, 255, 0.6)');
	gradient.addColorStop(0.55, 'rgba(120, 180, 255, 0.35)');
	gradient.addColorStop(1, 'rgba(255, 255, 255, 0.9)');
	ctx.fillStyle = gradient;
	ctx.fillRect(0, 0, textureCanvas.width, textureCanvas.height);

	const imageData = ctx.getImageData(0, 0, textureCanvas.width, textureCanvas.height);
	for (let i = 0; i < imageData.data.length; i += 4) {
		const noise = (Math.random() - 0.5) * 10;
		imageData.data[i] += noise;
		imageData.data[i + 1] += noise;
		imageData.data[i + 2] += noise;
	}
	ctx.putImageData(imageData, 0, 0);

	const texture = new THREE.CanvasTexture(textureCanvas);
	texture.wrapS = texture.wrapT = THREE.MirroredRepeatWrapping;
	texture.repeat.set(2, 2);
	texture.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 4;
	return texture;
};

const metalTexture = createMetalTexture();

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
camera.position.z = 5;

	const group = new THREE.Group();
	scene.add(group);

const accentColor = new THREE.Color('#00FF7F');
const secondaryColor = new THREE.Color('#9A1AFF');
const highlightColor = new THREE.Color('#6E6EFF');
const whiteColor = new THREE.Color('#fefefe');
const blendColor = new THREE.Color();
const emissiveColor = new THREE.Color();

const material = new THREE.MeshStandardMaterial({
	color: 0xffffff,
	metalness: 0.97,
	roughness: 0.12,
	map: metalTexture,
	envMapIntensity: 1.2,
	emissive: 0xffffff,
	emissiveIntensity: 0.08,
	transparent: true,
	opacity: 0.98,
});

const ring = new THREE.Mesh(new THREE.TorusGeometry(2.1, 0.18, 48, 140), material);
	group.add(ring);

	const pyramidGroup = new THREE.Group();
	pyramidGroup.scale.set(0.8, 0.8, 0.8);
	group.add(pyramidGroup);

	const geometry = new THREE.ConeGeometry(1.5, 2, 4);
	geometry.computeVertexNormals();
	geometry.rotateX(Math.PI);
	const pyramid = new THREE.Mesh(geometry, material);
	pyramidGroup.add(pyramid);

	const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
	scene.add(ambientLight);

	const mainLight = new THREE.PointLight(0xaaaaaa, 1.5, 100);
	mainLight.position.set(0, -5, 0);
	scene.add(mainLight);

	const topLight = new THREE.PointLight(0xbbbbbb, 1.0, 100);
	topLight.position.set(1, 1, 1);
	scene.add(topLight);

	const accentLight1 = new THREE.PointLight(0x00FF7F, 1.0, 50);
	accentLight1.position.set(-5, -5, 5);
	scene.add(accentLight1);

	const accentLight2 = new THREE.PointLight(0x9A1AFF, 1.0, 50);
	accentLight2.position.set(5, -5, -5);
	scene.add(accentLight2);

	const accentLight3 = new THREE.PointLight(0x6E6EFF, 1.0, 50);
	accentLight3.position.set(-5, 5, -5);
	scene.add(accentLight3);

	const rimLight1 = new THREE.DirectionalLight(0xffffff, 0.1);
	rimLight1.position.set(0, -5, 5);
	scene.add(rimLight1);

	const rimLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
	rimLight2.position.set(0, -5, -5);
	scene.add(rimLight2);

	const blurLight1 = new THREE.PointLight(0x00FF7F, 0.6, 30);
	blurLight1.position.set(3, 3, 3);
	scene.add(blurLight1);

const blurLight2 = new THREE.PointLight(0x9A1AFF, 0.6, 30);
blurLight2.position.set(-3, -3, 3);
scene.add(blurLight2);

const fluidMaterial = new THREE.MeshPhysicalMaterial({
	color: accentColor.clone().lerp(highlightColor, 0.5),
	metalness: 0.2,
	roughness: 0.05,
	clearcoat: 1,
	clearcoatRoughness: 0.1,
	transmission: 0.85,
	thickness: 0.4,
	opacity: 0.9,
	transparent: true,
});

const fluidPath = new THREE.CatmullRomCurve3(
	[
		new THREE.Vector3(0, 1.2, 0.6),
		new THREE.Vector3(-0.2, 0.7, 0.4),
		new THREE.Vector3(-0.25, 0.2, 0.1),
		new THREE.Vector3(-0.15, -0.4, -0.1),
		new THREE.Vector3(0, -0.9, -0.2),
		new THREE.Vector3(0.15, -1.4, -0.15),
	],
	false,
	'spline',
);

const fluidTrail = new THREE.Mesh(
	new THREE.TubeGeometry(fluidPath, 80, 0.04, 12, false),
	fluidMaterial.clone(),
);
fluidTrail.material.opacity = 0.3;
fluidTrail.material.transparent = true;
scene.add(fluidTrail);

const timeline = gsap.timeline({ repeat: -1 });
timeline
	.to(
		ring.rotation,
			{
				z: '+=6.28319',
				x: '+=6.28319',
				duration: 8,
				ease: 'power1.inOut',
			},
			0,
		)
		.to(
			group.rotation,
			{
				y: 6.28319,
				duration: 8,
				ease: 'power1.inOut',
			},
			0,
		)
		.to(
			pyramidGroup.rotation,
			{
				z: '-=6.28319',
				x: '-=6.28319',
				duration: 8,
				ease: 'power1.inOut',
			},
			0,
		);

	let mouseX = 0;
	let mouseY = 0;
	let targetRotationX = 0;
	let targetRotationY = 0;
	let currentRotationX = 0;
	let currentRotationY = 0;

	window.addEventListener('mousemove', (e) => {
		const rect = canvas.getBoundingClientRect();
		mouseX = (e.clientX - rect.left) / canvas.clientWidth;
		mouseY = (e.clientY - rect.top) / canvas.clientHeight;

		mainLight.position.x = (mouseX - 0.5) * 10;
		mainLight.position.z = (mouseY - 0.5) * 10;

		topLight.position.x = -mouseX * 10;
		topLight.position.z = -mouseY * 10;

		blurLight1.position.x = (mouseX - 0.5) * 6;
		blurLight1.position.z = (mouseY - 0.5) * 6;
		blurLight2.position.x = -(mouseX - 0.5) * 6;
		blurLight2.position.z = -(mouseY - 0.5) * 6;

		targetRotationX = (mouseY - 0.5) * 0.5;
		targetRotationY = (mouseX - 0.5) * 0.5;
	});

	const handleResize = () => {
		const width = canvas.clientWidth;
		const height = canvas.clientHeight;

		renderer.setSize(width, height);
		camera.aspect = width / height;
		camera.updateProjectionMatrix();

		if (width > height) {
			camera.position.z = 5;
		} else {
			camera.position.z = 7;
		}
	};

	window.addEventListener('resize', handleResize);
	handleResize();

function animate() {
	requestAnimationFrame(animate);

		currentRotationX += (targetRotationX - currentRotationX) * 0.05;
		currentRotationY += (targetRotationY - currentRotationY) * 0.05;

		pyramidGroup.rotation.x = currentRotationX;
		pyramidGroup.rotation.y = currentRotationY;

		const time = Date.now() * 0.001;
		blurLight1.position.y = 2 + Math.sin(time) * 0.02;
	blurLight2.position.y = -2 + Math.cos(time) * 0.02;

	const offsetSpeed = 0.02;
	metalTexture.offset.x = THREE.MathUtils.damp(metalTexture.offset.x, (metalTexture.offset.x + offsetSpeed * 0.01) % 1, 6, 0.016);
	metalTexture.offset.y = THREE.MathUtils.damp(metalTexture.offset.y, (metalTexture.offset.y + offsetSpeed * 0.006) % 1, 6, 0.016);
	metalTexture.needsUpdate = true;

	const pyramidHue = (time * 0.05) % 1;
	const ringHue = (1 - pyramidHue + 1) % 1;

	const paletteMixA = (Math.sin(time * 0.12) + 1) * 0.5;
	const paletteMixB = (Math.cos(time * 0.1) + 1) * 0.5;
	blendColor
		.copy(accentColor)
		.lerp(highlightColor, paletteMixA)
		.lerp(secondaryColor, paletteMixB * 0.6)
		.offsetHSL((pyramidHue - 0.5) * 0.2, 0, 0);
	emissiveColor.copy(blendColor).lerp(highlightColor, 0.5);
	material.color.copy(whiteColor).lerp(blendColor, 0.45);
	material.emissive.copy(emissiveColor).multiplyScalar(0.6);

	renderer.render(scene, camera);
}

	animate();
</script>
